# 유스케이스 명세 (Use Cases Specification)

본 문서는 대학교 데이터 시각화 대시보드의 주요 기능을 유스케이스 단위로 분해하여 상세히 기술합니다. 각 유스케이스는 Actor, Preconditions, Main Success Scenario, Extensions를 포함하여 개발자와 QA 엔지니어가 명확하게 이해할 수 있도록 작성되었습니다.

---

## UC-01: 사용자 로그인

### Actor
- 일반 사용자 (데이터 조회 권한)
- 관리자 사용자 (데이터 조회 + 업로드 권한)

### Preconditions
- 사용자가 로그인 페이지(`/login`)에 접근 가능해야 함
- 백엔드 API 서버(`/api/auth/token`)가 정상 작동 중이어야 함
- 사용자의 계정이 시스템에 등록되어 있어야 함

### Main Success Scenario
1. 사용자가 브라우저에서 로그인 페이지(`/login`)에 접근한다.
2. 시스템이 로그인 폼(아이디, 비밀번호 입력 필드 및 로그인 버튼)을 표시한다.
3. 사용자가 유효한 아이디를 입력 필드에 입력한다.
4. 사용자가 올바른 비밀번호를 입력 필드에 입력한다.
5. 사용자가 로그인 버튼을 클릭한다.
6. 시스템이 React Hook Form과 Zod 스키마로 입력 데이터를 검증한다.
7. 시스템이 `/api/auth/token` 엔드포인트로 POST 요청을 전송한다.
8. 백엔드가 Django 인증 시스템으로 사용자 자격 증명을 확인한다.
9. 백엔드가 JWT Access Token과 Refresh Token을 생성하여 JSON 응답으로 반환한다.
10. 시스템이 JWT 토큰을 브라우저 로컬 스토리지에 저장한다.
11. 시스템이 Zustand 스토어에 인증 상태(사용자 정보, 권한)를 업데이트한다.
12. 시스템이 성공 피드백(토스트 메시지)을 표시한다.
13. 시스템이 사용자를 메인 대시보드 페이지(`/`)로 자동 리다이렉트한다.

### Extensions

#### 1a. 필수 필드 미입력
- **조건:** 사용자가 아이디 또는 비밀번호를 입력하지 않고 로그인 버튼을 클릭한 경우
- **처리:**
  1. 시스템이 React Hook Form의 클라이언트 측 검증에서 오류를 감지한다.
  2. 시스템이 해당 입력 필드 하단에 "이 필드는 필수입니다" 오류 메시지를 표시한다.
  3. 시스템이 입력 필드에 빨간색 테두리 등 오류 스타일을 적용한다.
  4. 시스템이 서버 요청을 전송하지 않는다.
  5. 사용자가 필드를 올바르게 입력할 때까지 대기한다.

#### 1b. 잘못된 자격 증명
- **조건:** 사용자가 존재하지 않는 아이디 또는 잘못된 비밀번호를 입력한 경우
- **처리:**
  1. 시스템이 클라이언트 측 검증을 통과하고 API 요청을 전송한다.
  2. 백엔드가 사용자 자격 증명 확인에 실패한다.
  3. 백엔드가 HTTP 401 Unauthorized 응답(`{"detail": "Invalid credentials"}`)을 반환한다.
  4. 시스템이 로딩 인디케이터를 숨긴다.
  5. 시스템이 "아이디 또는 비밀번호가 올바르지 않습니다" 오류 메시지를 화면에 표시한다.
  6. 사용자가 올바른 정보를 재입력할 수 있도록 입력 필드를 유지한다.

#### 1c. 네트워크 오류
- **조건:** API 요청 전송 중 네트워크 연결 실패 또는 서버 응답 없음
- **처리:**
  1. 시스템이 API 요청을 전송한다.
  2. Fetch API에서 네트워크 오류가 발생한다.
  3. React Query가 최대 3회까지 자동 재시도를 실행한다.
  4. 재시도가 모두 실패한 경우, 시스템이 "네트워크 연결을 확인해주세요" 오류 메시지를 표시한다.
  5. 시스템이 "재시도" 버튼을 제공한다.
  6. 사용자가 재시도 버튼을 클릭하면 1단계로 돌아간다.

#### 1d. 서버 내부 오류 (HTTP 500)
- **조건:** 백엔드 서버에서 내부 오류 발생 (예: 데이터베이스 연결 실패)
- **처리:**
  1. 시스템이 API 요청을 전송한다.
  2. 백엔드가 HTTP 500 Internal Server Error 응답을 반환한다.
  3. 시스템이 로딩 인디케이터를 숨긴다.
  4. 시스템이 "일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요" 메시지를 표시한다.
  5. 기술적 세부사항은 사용자에게 노출하지 않는다.

---

## UC-02: 사용자 로그아웃

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 로그인되어 있어야 함 (JWT 토큰이 로컬 스토리지에 존재)
- 사용자가 보호된 페이지(대시보드 등)에 있어야 함

### Main Success Scenario
1. 사용자가 헤더의 로그아웃 버튼을 클릭한다.
2. 시스템이 로그아웃 확인 다이얼로그를 표시한다 (선택 사항).
3. 사용자가 확인을 클릭한다.
4. 시스템이 로컬 스토리지에서 JWT Access Token과 Refresh Token을 삭제한다.
5. 시스템이 Zustand 스토어의 인증 상태를 초기화한다.
6. 시스템이 React Query 캐시를 모두 초기화한다.
7. 시스템이 "로그아웃되었습니다" 성공 메시지를 표시한다.
8. 시스템이 사용자를 로그인 페이지(`/login`)로 리다이렉트한다.

### Extensions

#### 2a. 로그아웃 취소
- **조건:** 사용자가 확인 다이얼로그에서 "취소"를 클릭한 경우
- **처리:**
  1. 시스템이 확인 다이얼로그를 닫는다.
  2. 로그아웃 프로세스를 중단하고 현재 페이지를 유지한다.

---

## UC-03: 자동 로그인 (세션 복원)

### Actor
- 이전에 로그인한 사용자

### Preconditions
- 사용자의 브라우저 로컬 스토리지에 유효한 JWT 토큰이 저장되어 있어야 함
- 토큰의 만료 시간이 지나지 않았어야 함 (24시간 이내)

### Main Success Scenario
1. 사용자가 브라우저를 재시작하고 보호된 페이지(예: `/dashboard/performance`)에 직접 접근한다.
2. 시스템이 페이지 로드 시 로컬 스토리지에서 JWT 토큰을 확인한다.
3. 시스템이 JWT 토큰의 만료 시간을 클라이언트 측에서 검증한다.
4. 토큰이 유효한 경우, 시스템이 Zustand 스토어에 인증 상태를 복원한다.
5. 시스템이 요청한 페이지를 정상적으로 로드한다.
6. 시스템이 해당 페이지의 데이터 요청 시 JWT 토큰을 `Authorization: Bearer <token>` 헤더에 포함하여 전송한다.
7. 백엔드가 JWT 토큰의 서명과 만료 시간을 검증한다.
8. 백엔드가 정상 응답을 반환한다.
9. 시스템이 사용자 정보를 헤더에 표시한다.

### Extensions

#### 3a. 토큰 만료
- **조건:** JWT 토큰의 만료 시간이 24시간 경과한 경우
- **처리:**
  1. 시스템이 토큰 만료를 감지한다.
  2. 시스템이 Refresh Token으로 새 Access Token 발급을 시도한다 (Refresh Token이 구현된 경우).
  3. Refresh Token도 만료된 경우, 시스템이 "세션이 만료되었습니다. 다시 로그인해주세요" 메시지를 표시한다.
  4. 시스템이 로컬 스토리지의 모든 토큰을 삭제한다.
  5. 시스템이 사용자를 로그인 페이지(`/login`)로 리다이렉트한다.
  6. 시스템이 로그인 후 원래 접근하려던 페이지 경로를 쿼리 파라미터에 저장한다 (선택 사항).

#### 3b. 토큰 변조 또는 유효하지 않음
- **조건:** 로컬 스토리지의 JWT 토큰이 변조되었거나 서명이 유효하지 않음
- **처리:**
  1. 시스템이 API 요청 시 토큰을 헤더에 포함하여 전송한다.
  2. 백엔드가 JWT 서명 검증에 실패한다.
  3. 백엔드가 HTTP 401 Unauthorized 응답을 반환한다.
  4. 시스템이 "인증에 실패했습니다. 다시 로그인해주세요" 메시지를 표시한다.
  5. 시스템이 로컬 스토리지의 토큰을 삭제한다.
  6. 시스템이 사용자를 로그인 페이지로 리다이렉트한다.

---

## UC-04: CSV 파일 업로드

### Actor
- 관리자 사용자 (데이터 업로드 권한)

### Preconditions
- 사용자가 관리자 권한으로 로그인되어 있어야 함
- 사용자가 데이터 업로드 페이지(`/admin/upload`)에 접근 가능해야 함
- 업로드할 CSV 파일이 사용자의 로컬 시스템에 존재해야 함
- CSV 파일이 시스템에서 지원하는 형식과 컬럼 구조를 따라야 함

### Main Success Scenario
1. 사용자가 데이터 업로드 페이지(`/admin/upload`)에 접근한다.
2. 시스템이 파일 업로드 영역(드래그 앤 드롭 또는 파일 선택 버튼)을 표시한다.
3. 사용자가 CSV 파일을 드래그 앤 드롭하거나 파일 선택 다이얼로그에서 파일을 선택한다.
4. 시스템이 선택된 파일명과 파일 크기를 UI에 표시한다.
5. 사용자가 데이터 유형(실적/논문/학생/예산) 드롭다운에서 해당 유형을 선택한다.
6. 사용자가 "업로드" 버튼을 클릭한다.
7. 시스템이 파일 확장자가 `.csv`인지 검증한다.
8. 시스템이 파일 크기가 최대 허용 크기(예: 10MB) 이내인지 검증한다.
9. 시스템이 데이터 유형이 선택되었는지 검증한다.
10. 시스템이 로딩 인디케이터 또는 프로그레스 바를 표시한다.
11. 시스템이 FormData 객체를 생성하고 파일과 데이터 유형 메타데이터를 추가한다.
12. 시스템이 `/api/data/upload` 엔드포인트로 POST 요청(multipart/form-data)을 전송한다.
13. 백엔드가 Django REST Framework Serializer로 파일과 데이터 유형을 검증한다.
14. 백엔드가 임시 디렉토리에 파일을 저장한다.
15. 백엔드가 Pandas `read_csv()`로 CSV 파일을 읽고 DataFrame을 생성한다.
16. 백엔드가 데이터 유형에 따라 필수 컬럼 존재 여부를 확인한다.
17. 백엔드가 각 행의 데이터 유효성을 검증한다 (필수 컬럼, 데이터 타입, 범위 등).
18. 백엔드가 유효한 행만 Django ORM `bulk_create()` 또는 `update_or_create()`로 데이터베이스에 저장한다.
19. 백엔드가 UploadLog 모델에 업로드 기록을 저장한다 (파일명, 데이터 유형, 성공/실패 행 수).
20. 백엔드가 JSON 응답을 반환한다 (`{"success_count": 100, "failed_count": 0, "errors": []}`).
21. 시스템이 로딩 인디케이터를 숨긴다.
22. 시스템이 "100개 행이 성공적으로 업로드되었습니다" 성공 메시지를 표시한다.
23. 시스템이 업로드 이력 테이블에 새 항목을 추가한다.
24. 시스템이 React Query 캐시를 무효화하여 대시보드 데이터를 자동 갱신한다.

### Extensions

#### 4a. 잘못된 파일 형식
- **조건:** 사용자가 `.csv`가 아닌 파일(예: `.xlsx`, `.txt`)을 업로드 시도한 경우
- **처리:**
  1. 시스템이 파일 선택 시 또는 업로드 버튼 클릭 시 파일 확장자를 검증한다.
  2. 시스템이 "CSV 파일만 업로드 가능합니다" 오류 메시지를 표시한다.
  3. 시스템이 파일 선택 영역에 빨간색 테두리 등 오류 스타일을 적용한다.
  4. 시스템이 업로드 버튼을 비활성화한다.
  5. 사용자가 올바른 파일을 선택할 때까지 업로드가 진행되지 않는다.

#### 4b. 파일 크기 초과
- **조건:** 사용자가 허용된 최대 크기(예: 10MB)를 초과하는 파일을 업로드 시도한 경우
- **처리:**
  1. 시스템이 파일 크기를 검증한다.
  2. 시스템이 "파일 크기가 너무 큽니다. 최대 10MB까지 업로드 가능합니다" 오류 메시지를 표시한다.
  3. 시스템이 파일 선택을 취소하거나 다른 파일을 선택하도록 유도한다.
  4. 시스템이 업로드 버튼을 비활성화한다.

#### 4c. 데이터 유형 미선택
- **조건:** 사용자가 CSV 파일을 선택했으나 데이터 유형을 선택하지 않고 업로드 버튼을 클릭한 경우
- **처리:**
  1. 시스템이 폼 검증에서 데이터 유형 필드가 비어있음을 감지한다.
  2. 시스템이 "데이터 유형을 선택해주세요" 오류 메시지를 표시한다.
  3. 시스템이 데이터 유형 선택 필드에 빨간색 테두리를 적용한다.
  4. 시스템이 서버 요청을 전송하지 않는다.

#### 4d. CSV 컬럼 구조 불일치
- **조건:** CSV 파일의 컬럼이 선택한 데이터 유형의 필수 컬럼과 일치하지 않는 경우
- **처리:**
  1. 시스템이 파일 업로드 요청을 전송한다.
  2. 백엔드가 Pandas로 CSV 파일을 읽는다.
  3. 백엔드가 필수 컬럼(예: 실적 데이터의 경우 `year`, `month`, `department`, `target`, `actual`) 존재 여부를 확인한다.
  4. 필수 컬럼이 누락된 경우, 백엔드가 HTTP 400 Bad Request 응답을 반환한다 (`{"detail": "Missing required columns: ['target', 'actual']"}`).
  5. 시스템이 로딩 인디케이터를 숨긴다.
  6. 시스템이 "CSV 파일의 컬럼 구조가 올바르지 않습니다. 누락된 컬럼: target, actual" 오류 메시지를 표시한다.
  7. 시스템이 올바른 CSV 템플릿을 다운로드할 수 있는 링크를 제공한다.
  8. 시스템이 업로드 이력에 실패 기록을 추가한다 (선택 사항).

#### 4e. 부분 실패 (일부 행만 유효)
- **조건:** CSV 파일의 일부 행에 유효하지 않은 데이터가 포함된 경우 (예: 잘못된 날짜 형식, 음수 값)
- **처리:**
  1. 시스템이 파일 업로드 요청을 전송한다.
  2. 백엔드가 Pandas로 CSV 파일을 읽는다.
  3. 백엔드가 각 행의 유효성을 검증한다.
  4. 유효한 행만 데이터베이스에 저장하고, 유효하지 않은 행은 건너뛴다.
  5. 백엔드가 실패한 행 정보를 수집한다 (행 번호, 오류 원인).
  6. 백엔드가 HTTP 200 OK 또는 HTTP 207 Multi-Status 응답을 반환한다 (`{"success_count": 85, "failed_count": 15, "errors": [{"row": 5, "reason": "Invalid date format"}, ...]}`).
  7. 시스템이 로딩 인디케이터를 숨긴다.
  8. 시스템이 "100개 중 85개 행이 성공적으로 저장되었습니다" 메시지를 표시한다.
  9. 시스템이 성공/실패 행 수 통계를 표시한다.
  10. 시스템이 실패한 행 목록을 테이블 형식으로 표시한다 (행 번호, 오류 원인).
  11. 시스템이 실패한 행 데이터를 CSV로 다운로드할 수 있는 버튼을 제공한다.
  12. 시스템이 UploadLog에 성공/실패 통계를 기록한다.

#### 4f. 중복 데이터
- **조건:** 업로드된 CSV 파일의 데이터가 이미 데이터베이스에 존재하는 경우
- **처리:**
  1. 시스템이 파일 업로드 요청을 전송한다.
  2. 백엔드가 CSV 파일을 읽고 검증한다.
  3. 백엔드가 Django ORM `update_or_create()`로 중복 데이터를 처리한다 (기존 데이터는 업데이트, 새 데이터는 삽입).
  4. 백엔드가 업데이트된 행 수와 새로 삽입된 행 수를 집계한다.
  5. 백엔드가 HTTP 200 OK 응답을 반환한다 (`{"updated_count": 30, "created_count": 70}`).
  6. 시스템이 "30개 행이 업데이트되었고, 70개 행이 새로 추가되었습니다" 메시지를 표시한다.

#### 4g. 네트워크 오류 또는 서버 타임아웃
- **조건:** 대용량 파일 업로드 중 네트워크 연결이 끊기거나 서버 응답 시간이 초과된 경우
- **처리:**
  1. 시스템이 파일 업로드 요청을 전송한다.
  2. 네트워크 연결 실패 또는 타임아웃이 발생한다.
  3. Fetch API에서 네트워크 오류가 발생한다.
  4. React Query가 제한된 재시도(대용량 파일은 재시도 제한)를 실행한다.
  5. 시스템이 "업로드 중 오류가 발생했습니다. 네트워크 연결을 확인하고 다시 시도해주세요" 메시지를 표시한다.
  6. 시스템이 "재시도" 버튼과 "취소" 버튼을 제공한다.

#### 4h. 권한 없음 (일반 사용자 접근 시도)
- **조건:** 관리자가 아닌 일반 사용자가 데이터 업로드 페이지에 접근하려는 경우
- **처리:**
  1. 시스템이 페이지 로드 시 Zustand 스토어에서 사용자 권한을 확인한다.
  2. 시스템이 사용자에게 관리자 권한이 없음을 감지한다.
  3. 시스템이 "이 페이지에 접근할 권한이 없습니다" 메시지를 표시한다.
  4. 시스템이 사용자를 메인 대시보드 페이지(`/`)로 자동 리다이렉트한다.

---

## UC-05: 업로드 이력 조회

### Actor
- 관리자 사용자

### Preconditions
- 사용자가 관리자 권한으로 로그인되어 있어야 함
- 사용자가 데이터 업로드 페이지(`/admin/upload`)에 있어야 함
- UploadLog 테이블에 하나 이상의 업로드 기록이 존재해야 함 (선택 사항)

### Main Success Scenario
1. 사용자가 데이터 업로드 페이지(`/admin/upload`)에 접근한다.
2. 시스템이 페이지 로드 시 `/api/data/upload-logs` 엔드포인트로 GET 요청을 전송한다.
3. 백엔드가 UploadLog 모델에서 최근 업로드 기록을 조회한다 (페이지네이션 적용, 예: 최근 20개).
4. 백엔드가 Serializer로 데이터를 직렬화한다.
5. 백엔드가 JSON 응답을 반환한다 (업로드 로그 목록).
6. 시스템이 React Query로 응답 데이터를 수신하고 캐싱한다.
7. 시스템이 페이지 하단에 업로드 이력 테이블을 렌더링한다.
8. 테이블에 각 항목의 정보(파일명, 데이터 유형, 업로드 일시, 성공 행 수, 실패 행 수, 업로드한 사용자)를 표시한다.
9. 시스템이 페이지네이션 컨트롤을 표시한다.
10. 시스템이 각 항목에 "상세 보기" 버튼을 표시한다.

### Extensions

#### 5a. 업로드 이력 없음
- **조건:** UploadLog 테이블에 데이터가 없는 경우
- **처리:**
  1. 백엔드가 빈 배열을 반환한다.
  2. 시스템이 빈 상태(Empty State) UI를 표시한다.
  3. 시스템이 "아직 업로드 이력이 없습니다" 메시지를 표시한다.

#### 5b. 페이지네이션
- **조건:** 사용자가 페이지네이션 컨트롤에서 다음 페이지 버튼을 클릭한 경우
- **처리:**
  1. 시스템이 페이지 번호를 증가시킨다.
  2. 시스템이 `/api/data/upload-logs?page=2` 엔드포인트로 GET 요청을 전송한다.
  3. 백엔드가 다음 페이지의 데이터를 반환한다.
  4. 시스템이 테이블을 업데이트하여 다음 페이지의 항목을 표시한다.

---

## UC-06: 업로드 이력 상세 조회

### Actor
- 관리자 사용자

### Preconditions
- 사용자가 업로드 이력 테이블을 조회하고 있어야 함
- 조회하려는 업로드 기록이 UploadLog 테이블에 존재해야 함

### Main Success Scenario
1. 사용자가 업로드 이력 테이블에서 특정 항목의 "상세 보기" 버튼을 클릭한다.
2. 시스템이 모달 또는 확장 패널을 표시한다.
3. 시스템이 `/api/data/upload-logs/{id}` 엔드포인트로 GET 요청을 전송한다.
4. 백엔드가 해당 UploadLog의 상세 정보를 조회한다 (오류 메시지, 실패한 행 상세 정보 포함).
5. 백엔드가 JSON 응답을 반환한다.
6. 시스템이 React Query로 응답 데이터를 수신한다.
7. 시스템이 모달에 상세 정보를 렌더링한다:
   - 파일명, 파일 크기
   - 데이터 유형
   - 업로드 일시
   - 업로드한 사용자
   - 전체 행 수, 성공 행 수, 실패 행 수
   - 실패한 행 목록 테이블 (행 번호, 오류 원인)
8. 시스템이 "닫기" 버튼을 표시한다.

### Extensions

#### 6a. 실패한 행 없음
- **조건:** 선택한 업로드 기록에 실패한 행이 없는 경우
- **처리:**
  1. 시스템이 실패한 행 섹션을 숨기거나 "모든 행이 성공적으로 업로드되었습니다" 메시지를 표시한다.

#### 6b. 모달 닫기
- **조건:** 사용자가 모달의 "닫기" 버튼 또는 모달 외부를 클릭한 경우
- **처리:**
  1. 시스템이 모달을 닫는다.
  2. 업로드 이력 테이블 화면으로 돌아간다.

---

## UC-07: 메인 대시보드 조회

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 로그인되어 있어야 함
- 데이터베이스에 하나 이상의 데이터(실적/논문/학생/예산)가 존재해야 함

### Main Success Scenario
1. 사용자가 메인 대시보드 페이지(`/`)에 접근한다.
2. 시스템이 페이지 로드 시 `/api/dashboard/overview` 엔드포인트로 GET 요청을 전송한다.
3. 백엔드가 4개 주요 지표(실적, 논문, 학생, 예산)의 요약 데이터를 조회한다.
4. 백엔드가 각 데이터 모델에서 집계 쿼리를 실행한다 (예: 최신 달성률, 총 논문 수, 총 학생 수, 예산 집행률).
5. 백엔드가 Serializer로 데이터를 직렬화한다.
6. 백엔드가 JSON 응답을 반환한다 (4개 카드 데이터).
7. 시스템이 React Query로 응답 데이터를 수신하고 캐싱한다 (staleTime 5분).
8. 시스템이 로딩 중 스켈레톤 UI를 표시한다.
9. 로딩 완료 후, 시스템이 4개 주요 지표 카드를 Grid Layout으로 렌더링한다:
   - 실적 카드: 최신 달성률, 간단한 차트
   - 논문 카드: 총 논문 수, 간단한 차트
   - 학생 카드: 총 학생 수, 간단한 차트
   - 예산 카드: 예산 집행률, 간단한 차트
10. 각 카드에 상세 페이지로 이동하는 버튼 또는 링크를 표시한다.

### Extensions

#### 7a. 데이터 없음
- **조건:** 데이터베이스에 아직 업로드된 데이터가 없는 경우
- **처리:**
  1. 백엔드가 빈 결과 또는 기본값을 반환한다.
  2. 시스템이 빈 상태(Empty State) UI를 표시한다.
  3. 시스템이 "아직 데이터가 없습니다. 데이터를 업로드해주세요" 메시지를 표시한다.
  4. 관리자인 경우, 시스템이 데이터 업로드 페이지로 이동하는 버튼을 제공한다.

#### 7b. API 오류
- **조건:** 백엔드에서 오류가 발생한 경우 (예: 데이터베이스 쿼리 실패)
- **처리:**
  1. 백엔드가 HTTP 500 Internal Server Error 응답을 반환한다.
  2. 시스템이 로딩 인디케이터를 숨긴다.
  3. 시스템이 "데이터를 불러오는 중 오류가 발생했습니다" 메시지를 표시한다.
  4. 시스템이 "재시도" 버튼을 제공한다.

#### 7c. 느린 로딩 (3초 초과)
- **조건:** 백엔드 응답이 3초 이상 지연되는 경우
- **처리:**
  1. 시스템이 로딩 인디케이터를 지속 표시한다.
  2. 3초 경과 후, 시스템이 "데이터를 불러오는 중입니다. 잠시만 기다려주세요" 추가 메시지를 표시한다.
  3. 타임아웃 설정(예: 30초)에 따라 최대 대기 시간 후 오류 처리로 전환한다.

---

## UC-08: 실적 대시보드 조회

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 로그인되어 있어야 함
- PerformanceData 테이블에 데이터가 존재해야 함

### Main Success Scenario
1. 사용자가 실적 대시보드 페이지(`/dashboard/performance`)에 접근한다.
2. 시스템이 기본 필터(예: 최근 1년, 모든 부서)로 `/api/dashboard/performance` 엔드포인트로 GET 요청을 전송한다.
3. 백엔드가 쿼리 파라미터로 필터 조건을 수신한다.
4. 백엔드가 PerformanceData 모델에서 필터링 및 집계 쿼리를 실행한다.
5. 백엔드가 차트 데이터 형식으로 가공한다 (시계열, 부서별 집계 등).
6. 백엔드가 Serializer로 데이터를 직렬화한다.
7. 백엔드가 JSON 응답을 반환한다 (차트 데이터, 통계 데이터).
8. 시스템이 React Query로 응답 데이터를 수신하고 캐싱한다.
9. 시스템이 로딩 중 스켈레톤 UI를 표시한다.
10. 로딩 완료 후, 시스템이 2x2 Grid Layout으로 차트를 렌더링한다:
    - 목표 대비 실적 추이 (라인 차트)
    - 부서별 달성률 (막대 차트)
    - 월별 실적 분포 (라인 차트)
    - 전체 달성률 요약 (파이 차트 또는 게이지)
11. 시스템이 필터 컨트롤(연도, 월, 부서 선택 드롭다운)을 표시한다.
12. 시스템이 페이지 하단에 데이터 테이블을 표시한다.

### Extensions

#### 8a. 필터링된 결과 없음
- **조건:** 사용자가 특정 연도 및 부서로 필터링했으나 해당 조건의 데이터가 없는 경우
- **처리:**
  1. 시스템이 필터 변경 시 API 요청을 전송한다.
  2. 백엔드가 필터링 쿼리 실행 결과 빈 배열을 반환한다.
  3. 시스템이 차트 영역에 빈 상태 UI를 표시한다.
  4. 시스템이 "선택한 조건에 해당하는 데이터가 없습니다" 메시지를 표시한다.
  5. 시스템이 "필터 초기화" 버튼을 제공한다.

#### 8b. 차트 렌더링 오류
- **조건:** 백엔드에서 올바른 데이터를 반환했으나 차트 라이브러리에서 렌더링 실패
- **처리:**
  1. 클라이언트의 차트 컴포넌트에서 데이터 처리 중 오류가 발생한다.
  2. Error Boundary가 오류를 캐치한다.
  3. 시스템이 차트 영역에 "차트를 표시할 수 없습니다" 오류 메시지를 표시한다.
  4. 시스템이 대체 UI로 데이터 테이블만 표시한다.
  5. 시스템이 "새로고침" 버튼을 제공한다.

---

## UC-09: 논문/학생/예산 대시보드 조회

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 로그인되어 있어야 함
- 해당 데이터 테이블(PaperData/StudentData/BudgetData)에 데이터가 존재해야 함

### Main Success Scenario
논문, 학생, 예산 대시보드는 실적 대시보드(UC-08)와 동일한 상호작용 흐름을 따릅니다.

1. 사용자가 각 대시보드 페이지에 접근한다 (`/dashboard/papers`, `/dashboard/students`, `/dashboard/budget`).
2. 시스템이 해당 데이터 엔드포인트로 GET 요청을 전송한다 (`/api/dashboard/papers`, `/api/dashboard/students`, `/api/dashboard/budget`).
3. 백엔드가 해당 데이터 모델에서 데이터를 조회하고 집계한다.
4. 백엔드가 JSON 응답을 반환한다.
5. 시스템이 React Query로 응답 데이터를 수신하고 차트를 렌더링한다.
6. 시스템이 각 대시보드에 맞는 차트를 표시한다:
   - **논문:** 국내/국제 논문 수, 연도별 추이, 부서별 분포
   - **학생:** 학년별/전공별 학생 수, 학기별 추이, 재학생 통계
   - **예산:** 분기별 예산 집행률, 부서별 예산, 카테고리별 지출
7. 시스템이 필터 컨트롤과 데이터 테이블을 표시한다.

### Extensions
논문, 학생, 예산 대시보드의 엣지케이스는 실적 대시보드(UC-08)의 Extensions와 동일하게 처리됩니다.

---

## UC-10: 데이터 테이블 조회 및 정렬

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 대시보드 페이지에 있어야 함
- 대시보드에 표시할 데이터가 존재해야 함

### Main Success Scenario
1. 사용자가 대시보드 하단의 데이터 테이블 영역을 확인한다.
2. 시스템이 차트 데이터와 동일한 API 응답에서 테이블 데이터를 추출한다 (또는 별도 API 요청).
3. 시스템이 shadcn-ui Table 컴포넌트에 데이터를 바인딩한다.
4. 시스템이 테이블을 렌더링한다 (컬럼: 연도, 월, 부서, 목표, 실적 등).
5. 시스템이 정렬 가능한 컬럼 헤더에 정렬 아이콘을 표시한다.
6. 사용자가 특정 컬럼 헤더(예: "달성률")를 클릭한다.
7. 시스템이 해당 컬럼 기준으로 데이터를 오름차순으로 정렬한다.
8. 사용자가 동일한 컬럼 헤더를 다시 클릭한다.
9. 시스템이 해당 컬럼 기준으로 데이터를 내림차순으로 정렬한다.
10. 시스템이 페이지네이션 컨트롤을 표시한다.
11. 시스템이 CSV 다운로드 버튼을 표시한다 (선택 사항).

### Extensions

#### 10a. 페이지네이션
- **조건:** 테이블 데이터가 한 페이지에 표시하기에 너무 많은 경우 (예: 100개 이상)
- **처리:**
  1. 시스템이 페이지네이션을 적용하여 한 페이지에 20개 항목만 표시한다.
  2. 사용자가 페이지네이션 컨트롤에서 다음 페이지 버튼을 클릭한다.
  3. 시스템이 클라이언트 측에서 다음 페이지 데이터를 계산하여 표시한다 (또는 서버에 페이지네이션 요청 전송).

#### 10b. 정렬 상태 유지
- **조건:** 사용자가 정렬 후 페이지를 새로고침하는 경우
- **처리:**
  1. 시스템이 정렬 상태를 URL 쿼리 파라미터에 저장한다 (예: `?sort=achievement_rate&order=desc`).
  2. 페이지 재로드 시 시스템이 URL 파라미터를 읽어 정렬 상태를 복원한다.

---

## UC-11: 데이터 다운로드 (CSV Export)

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 대시보드 페이지에 있어야 함
- 다운로드할 데이터가 존재해야 함

### Main Success Scenario
1. 사용자가 데이터 테이블 하단의 "CSV 다운로드" 버튼을 클릭한다.
2. 시스템이 현재 필터링된 데이터를 기반으로 다운로드 요청을 생성한다.
3. 시스템이 `/api/dashboard/performance/export` 엔드포인트로 GET 요청을 전송한다 (필터 파라미터 포함).
4. 백엔드가 필터링된 데이터를 조회한다.
5. 백엔드가 Pandas `to_csv()`로 CSV 파일을 생성한다.
6. 백엔드가 HTTP 응답으로 CSV 파일을 반환한다 (`Content-Type: text/csv`, `Content-Disposition: attachment; filename="performance_data.csv"`).
7. 시스템이 브라우저의 다운로드 기능을 트리거한다.
8. 브라우저가 파일 다운로드 다이얼로그를 표시한다.
9. 사용자가 파일을 저장할 위치를 선택하고 저장한다.
10. 시스템이 "파일이 다운로드되었습니다" 성공 피드백을 표시한다 (선택 사항).

### Extensions

#### 11a. 다운로드 실패 (네트워크 오류)
- **조건:** 다운로드 요청 중 네트워크 연결이 끊긴 경우
- **처리:**
  1. 시스템이 네트워크 오류를 감지한다.
  2. 시스템이 "다운로드 중 오류가 발생했습니다. 다시 시도해주세요" 메시지를 표시한다.
  3. 사용자가 다시 다운로드 버튼을 클릭할 수 있다.

#### 11b. 빈 데이터 다운로드 시도
- **조건:** 현재 필터링된 결과가 비어있는 경우
- **처리:**
  1. 시스템이 다운로드 요청 전에 데이터 존재 여부를 확인한다.
  2. 데이터가 없는 경우, 시스템이 "다운로드할 데이터가 없습니다" 메시지를 표시한다.
  3. 다운로드 요청을 전송하지 않는다.

---

## UC-12: 필터 적용

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 대시보드 페이지에 있어야 함
- 필터링 가능한 데이터가 존재해야 함

### Main Success Scenario
1. 사용자가 대시보드 페이지의 필터 컨트롤을 확인한다.
2. 사용자가 연도 드롭다운에서 특정 연도(예: 2024)를 선택한다.
3. 사용자가 부서 드롭다운에서 특정 부서(예: "컴퓨터공학과")를 선택한다.
4. 시스템이 필터 상태를 React 로컬 상태에 업데이트한다.
5. 시스템이 URL 쿼리 파라미터를 업데이트한다 (예: `?year=2024&department=컴퓨터공학과`).
6. 시스템이 React Query의 queryKey가 변경되어 자동으로 새로운 API 요청을 트리거한다.
7. 시스템이 `/api/dashboard/performance?year=2024&department=컴퓨터공학과` 엔드포인트로 GET 요청을 전송한다.
8. 백엔드가 필터링된 데이터를 조회하고 반환한다.
9. 시스템이 React Query로 응답 데이터를 수신한다.
10. 시스템이 로딩 중 차트 영역에 로딩 인디케이터를 표시한다.
11. 로딩 완료 후, 시스템이 필터링된 데이터로 차트를 재렌더링한다.
12. 시스템이 데이터 테이블도 필터링된 데이터로 업데이트한다.

### Extensions

#### 12a. 필터 초기화
- **조건:** 사용자가 "필터 초기화" 버튼을 클릭한 경우
- **처리:**
  1. 시스템이 모든 필터 값을 기본값으로 재설정한다.
  2. 시스템이 URL 쿼리 파라미터를 제거한다.
  3. 시스템이 기본 필터로 API 요청을 전송한다.
  4. 시스템이 차트와 테이블을 기본 데이터로 업데이트한다.

#### 12b. URL 직접 입력으로 필터 적용
- **조건:** 사용자가 URL에 직접 쿼리 파라미터를 입력하여 페이지에 접근한 경우 (예: `/dashboard/performance?year=2024`)
- **처리:**
  1. 시스템이 페이지 로드 시 URL 쿼리 파라미터를 읽는다.
  2. 시스템이 필터 컨트롤의 초기값을 URL 파라미터로 설정한다.
  3. 시스템이 해당 필터로 API 요청을 전송한다.
  4. 시스템이 필터링된 데이터를 표시한다.

---

## UC-13: 차트 상호작용 (툴팁, 줌)

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 대시보드 페이지에 있어야 함
- 차트가 정상적으로 렌더링되어 있어야 함

### Main Success Scenario (호버 툴팁)
1. 사용자가 차트 위에 마우스 커서를 올려 특정 데이터 포인트를 호버한다.
2. 차트 라이브러리(Recharts 또는 Chart.js)의 이벤트 핸들러가 실행된다.
3. 시스템이 호버된 데이터 포인트의 상세 정보를 계산한다 (예: 2024년 3월, 달성률 95%).
4. 시스템이 툴팁을 마우스 커서 근처에 표시한다.
5. 툴팁에 데이터 포인트의 상세 정보를 표시한다.
6. 사용자가 마우스를 다른 곳으로 이동하면 툴팁이 사라진다.

### Main Success Scenario (줌 인/아웃)
1. 사용자가 차트 영역을 마우스로 드래그하여 특정 범위를 선택한다.
2. 차트 라이브러리가 드래그 이벤트를 감지한다.
3. 시스템이 선택된 범위로 차트를 줌 인한다.
4. 시스템이 줌 레벨을 로컬 상태에 저장한다.
5. 시스템이 "줌 초기화" 버튼을 표시한다.
6. 사용자가 "줌 초기화" 버튼을 클릭한다.
7. 시스템이 차트를 원래 범위로 복원한다.

### Extensions

#### 13a. 차트 라이브러리가 툴팁을 지원하지 않음
- **조건:** 사용된 차트 라이브러리가 툴팁 기능을 제공하지 않는 경우
- **처리:**
  1. 시스템이 커스텀 툴팁 컴포넌트를 구현한다.
  2. 마우스 이벤트로 툴팁 위치와 내용을 계산하여 표시한다.

---

## UC-14: 페이지 네비게이션

### Actor
- 인증된 사용자 (일반 사용자, 관리자)

### Preconditions
- 사용자가 로그인되어 있어야 함

### Main Success Scenario
1. 사용자가 헤더의 네비게이션 메뉴에서 특정 항목(예: "논문")을 클릭한다.
2. 시스템이 Next.js Router의 `router.push('/dashboard/papers')`를 호출한다.
3. 시스템이 현재 페이지 컴포넌트를 언마운트한다.
4. 시스템이 URL을 `/dashboard/papers`로 변경한다.
5. 시스템이 논문 대시보드 페이지 컴포넌트를 마운트한다.
6. 시스템이 페이지 전환 애니메이션을 표시한다 (선택 사항).
7. 시스템이 새 페이지의 데이터 요청을 시작한다.
8. 시스템이 로딩 중 스켈레톤 UI를 표시한다.
9. 로딩 완료 후, 시스템이 논문 대시보드를 렌더링한다.

### Extensions

#### 14a. 브라우저 뒤로 가기 버튼 클릭
- **조건:** 사용자가 브라우저의 뒤로 가기 버튼을 클릭한 경우
- **처리:**
  1. 시스템이 브라우저 히스토리 스택에서 이전 페이지를 확인한다.
  2. 시스템이 이전 페이지로 네비게이션한다.
  3. React Query 캐시에서 이전 페이지의 데이터를 재사용한다 (캐시가 유효한 경우).

---

## UC-15: 전역 오류 처리

### Actor
- 모든 사용자 (인증 여부 무관)

### Preconditions
- 애플리케이션이 실행 중이어야 함

### Main Success Scenario
1. 애플리케이션의 어디에서든 예기치 않은 오류가 발생한다 (예: JavaScript 런타임 오류).
2. React Error Boundary가 오류를 캐치한다.
3. 시스템이 오류 정보를 콘솔에 로깅한다.
4. 시스템이 대체 UI(Fallback UI)를 렌더링한다.
5. 대체 UI에 "예기치 않은 오류가 발생했습니다" 메시지를 표시한다.
6. 시스템이 "홈으로 돌아가기" 버튼과 "페이지 새로고침" 버튼을 제공한다.
7. 사용자가 "홈으로 돌아가기" 버튼을 클릭한다.
8. 시스템이 사용자를 메인 대시보드 페이지(`/`)로 리다이렉트한다.

### Extensions

#### 15a. 페이지 새로고침
- **조건:** 사용자가 "페이지 새로고침" 버튼을 클릭한 경우
- **처리:**
  1. 시스템이 `window.location.reload()`를 호출한다.
  2. 브라우저가 페이지를 완전히 새로고침한다.
  3. 오류가 일시적인 경우 정상적으로 페이지가 로드된다.

---

## UC-16: 접근 권한 확인

### Actor
- 모든 사용자 (인증 여부 무관)

### Preconditions
- 사용자가 보호된 페이지에 접근하려고 시도

### Main Success Scenario (인증된 사용자)
1. 사용자가 보호된 페이지(예: `/dashboard/performance`)에 접근한다.
2. 시스템이 페이지 컴포넌트의 useEffect 또는 미들웨어에서 인증 상태를 확인한다.
3. 시스템이 Zustand 스토어에서 JWT 토큰과 사용자 정보를 확인한다.
4. 사용자가 인증되어 있고 토큰이 유효한 경우, 시스템이 페이지를 정상적으로 렌더링한다.

### Extensions

#### 16a. 인증되지 않은 사용자
- **조건:** 사용자가 로그인하지 않았거나 JWT 토큰이 없는 경우
- **처리:**
  1. 시스템이 인증 상태 확인에서 JWT 토큰이 없음을 감지한다.
  2. 시스템이 "로그인이 필요합니다" 메시지를 표시한다.
  3. 시스템이 사용자를 로그인 페이지(`/login`)로 리다이렉트한다.
  4. 시스템이 원래 접근하려던 페이지 경로를 쿼리 파라미터에 저장한다 (예: `/login?redirect=/dashboard/performance`).
  5. 로그인 성공 후 시스템이 원래 페이지로 사용자를 리다이렉트한다.

#### 16b. 권한 없는 사용자 (일반 사용자가 관리자 페이지 접근)
- **조건:** 일반 사용자가 관리자 전용 페이지(예: `/admin/upload`)에 접근하려는 경우
- **처리:**
  1. 시스템이 페이지 접근 시 사용자 권한을 확인한다.
  2. 시스템이 Zustand 스토어에서 사용자의 `is_admin` 값을 확인한다.
  3. `is_admin`이 `false`인 경우, 시스템이 "이 페이지에 접근할 권한이 없습니다" 메시지를 표시한다.
  4. 시스템이 사용자를 메인 대시보드 페이지(`/`)로 리다이렉트한다.

---

## UC-17: 데이터 자동 갱신 (Background Refetch)

### Actor
- 인증된 사용자 (대시보드 페이지에 머물러 있는 사용자)

### Preconditions
- 사용자가 대시보드 페이지에 일정 시간(예: 5분) 이상 머물러 있어야 함
- React Query의 `staleTime` 및 `refetchInterval` 설정이 활성화되어 있어야 함

### Main Success Scenario
1. 사용자가 실적 대시보드 페이지에 5분 이상 머물러 있다.
2. React Query의 `staleTime`이 만료되어 데이터가 stale 상태로 변경된다.
3. React Query가 `refetchInterval` 설정에 따라 백그라운드에서 자동으로 데이터를 재요청한다.
4. 시스템이 `/api/dashboard/performance` 엔드포인트로 GET 요청을 전송한다.
5. 백엔드가 최신 데이터를 반환한다.
6. React Query가 캐시를 업데이트한다.
7. 시스템이 UI를 자동으로 재렌더링하여 최신 데이터를 표시한다.
8. 사용자에게 눈에 띄는 로딩 표시가 없다 (백그라운드 갱신).
9. 시스템이 선택적으로 "데이터가 업데이트되었습니다" 알림을 표시한다 (토스트 메시지).

### Extensions

#### 17a. 백그라운드 갱신 실패
- **조건:** 백그라운드 데이터 갱신 중 네트워크 오류 또는 서버 오류 발생
- **처리:**
  1. React Query가 재시도 로직을 실행한다 (최대 3회).
  2. 재시도가 모두 실패한 경우, 시스템이 캐시된 기존 데이터를 유지한다.
  3. 시스템이 "데이터 갱신 중 오류가 발생했습니다" 알림을 표시한다 (선택 사항).
  4. 사용자는 계속 기존 데이터를 볼 수 있다.

#### 17b. 사용자가 다른 탭에서 돌아옴
- **조건:** 사용자가 브라우저의 다른 탭으로 이동했다가 다시 대시보드 탭으로 돌아온 경우
- **처리:**
  1. React Query의 `refetchOnWindowFocus` 설정에 따라 자동으로 데이터를 재요청한다.
  2. 시스템이 최신 데이터를 가져와 UI를 업데이트한다.

---

## UC-18: 반응형 디자인 (모바일/태블릿 접근)

### Actor
- 모든 사용자 (모바일 또는 태블릿 기기 사용자)

### Preconditions
- 사용자가 모바일 또는 태블릿 기기로 애플리케이션에 접근

### Main Success Scenario
1. 사용자가 스마트폰 브라우저에서 대시보드 페이지에 접근한다.
2. 시스템이 Tailwind CSS의 반응형 클래스(`md:`, `lg:` 등)에 따라 레이아웃을 자동 조정한다.
3. 시스템이 헤더의 네비게이션 메뉴를 햄버거 메뉴 아이콘으로 전환한다.
4. 시스템이 4개 카드를 2x2 Grid에서 1열 레이아웃으로 변경한다.
5. 시스템이 차트 크기를 화면에 맞게 축소한다.
6. 시스템이 데이터 테이블을 가로 스크롤 가능하게 만든다.
7. 사용자가 햄버거 메뉴 아이콘을 터치한다.
8. 시스템이 사이드 드로어 또는 드롭다운 메뉴를 표시한다.
9. 사용자가 메뉴에서 원하는 페이지를 선택한다.
10. 시스템이 해당 페이지로 네비게이션하고 메뉴를 닫는다.

### Extensions

#### 18a. 데스크톱에서 브라우저 창 크기 조정
- **조건:** 사용자가 데스크톱에서 브라우저 창을 축소하는 경우
- **처리:**
  1. 시스템이 화면 너비 변화를 감지한다.
  2. 시스템이 Tailwind CSS 반응형 클래스에 따라 레이아웃을 자동 조정한다.
  3. 필요시 햄버거 메뉴로 전환한다.

---

## UC-19: API 요청 최적화 (Debounce)

### Actor
- 인증된 사용자 (필터 입력을 사용하는 사용자)

### Preconditions
- 사용자가 대시보드 페이지에서 텍스트 입력 필터를 사용 중이어야 함

### Main Success Scenario
1. 사용자가 부서명 검색 필드에 "컴퓨터"를 빠르게 입력한다.
2. 시스템이 react-use의 `useDebounce` 훅으로 입력을 디바운싱한다.
3. 사용자가 입력을 멈춘다.
4. 시스템이 마지막 입력 후 500ms 대기한다.
5. 500ms 경과 후, 시스템이 디바운싱된 값("컴퓨터")으로 API 요청을 전송한다.
6. 백엔드가 필터링된 데이터를 반환한다.
7. 시스템이 차트와 테이블을 업데이트한다.

### Extensions

#### 19a. 디바운싱 중 사용자가 계속 입력
- **조건:** 사용자가 500ms 대기 시간 내에 계속 입력하는 경우
- **처리:**
  1. 시스템이 디바운스 타이머를 리셋한다.
  2. 사용자가 입력을 멈출 때까지 API 요청을 전송하지 않는다.
  3. 최종 입력 후 500ms 경과 시 API 요청을 전송한다.

---

## UC-20: 보안 처리 (XSS 및 SQL Injection 방지)

### Actor
- 악의적인 사용자 (공격 시도자)

### Preconditions
- 애플리케이션이 실행 중이어야 함

### Main Success Scenario (XSS 방지)
1. 악의적인 사용자가 로그인 페이지의 아이디 필드에 `<script>alert('XSS')</script>`를 입력한다.
2. 시스템이 React의 자동 이스케이핑 기능으로 입력값을 안전하게 처리한다.
3. 시스템이 입력값을 문자열 그대로 렌더링하여 스크립트가 실행되지 않는다.
4. 백엔드가 Django REST Framework Serializer로 입력 데이터를 검증한다.
5. 백엔드가 악의적인 스크립트를 제거하거나 이스케이핑한다.
6. 공격이 차단된다.

### Main Success Scenario (SQL Injection 방지)
1. 악의적인 사용자가 필터 입력 필드에 `'; DROP TABLE users; --`를 입력한다.
2. 시스템이 입력값을 API 요청으로 전송한다.
3. 백엔드가 Django ORM을 사용하여 쿼리를 실행한다.
4. Django ORM이 자동으로 쿼리 파라미터를 이스케이핑하여 SQL Injection을 방지한다.
5. 입력값이 단순 문자열로 처리되어 SQL 구문이 실행되지 않는다.
6. 공격이 차단된다.

---

## 요약

본 문서는 대학교 데이터 시각화 대시보드의 모든 주요 기능을 20개의 유스케이스로 분해하여 상세히 기술하였습니다. 각 유스케이스는 다음을 포함합니다:

- **Actor:** 해당 유스케이스를 수행하는 사용자 또는 시스템
- **Preconditions:** 유스케이스가 시작되기 위한 필수 조건
- **Main Success Scenario:** 목표를 문제없이 달성하는 단계별 과정 (Happy Path)
- **Extensions:** 성공 시나리오에서 발생 가능한 모든 예외 상황, 오류, 대안적인 흐름

이 명세는 개발자가 기능을 구현하고, QA 엔지니어가 테스트 케이스를 작성하는 데 명확한 기준을 제공합니다.
