# 사용자 상호작용 명세 (User Flow Specification)

본 문서는 대학교 데이터 시각화 대시보드의 주요 기능에 대한 사용자 상호작용을 '입력, 처리, 출력' 구조로 정의합니다.

---

## 1. 사용자 인증 (User Authentication)

### 1.1. 로그인

#### 성공 시나리오 (Happy Path)

**입력:**
- 사용자가 로그인 페이지(`/login`)에 접근
- 아이디 입력 필드에 유효한 아이디 입력
- 비밀번호 입력 필드에 비밀번호 입력
- 로그인 버튼 클릭

**처리:**
1. 클라이언트: React Hook Form이 폼 데이터 검증 (필수 필드 확인)
2. 클라이언트: Zod 스키마로 입력 형식 유효성 검증
3. 클라이언트: `@/lib/remote/api-client`를 통해 `/api/auth/token` 엔드포인트로 POST 요청
4. 서버: Django REST Framework가 요청 데이터 수신
5. 서버: Serializer로 요청 데이터 검증
6. 서버: Django 인증 시스템으로 사용자 자격 증명 확인
7. 서버: djangorestframework-simplejwt가 JWT Access Token 및 Refresh Token 생성
8. 서버: JSON 응답으로 토큰 반환
9. 클라이언트: React Query가 응답 데이터 수신
10. 클라이언트: JWT 토큰을 로컬 스토리지 또는 쿠키에 저장
11. 클라이언트: Zustand 스토어에 인증 상태 업데이트
12. 클라이언트: Next.js Router로 메인 대시보드(`/`)로 리다이렉트

**출력:**
- 로딩 인디케이터 숨김
- 성공 피드백 표시 (토스트 메시지 또는 알림)
- 메인 대시보드 페이지로 자동 이동
- 헤더에 사용자 정보 및 로그아웃 버튼 표시

**사이드이펙트:**
- 인증 상태가 전역 상태 관리 스토어에 저장됨
- JWT 토큰이 브라우저 스토리지에 저장됨
- 이후 모든 API 요청 헤더에 `Authorization: Bearer <token>` 자동 포함

#### 실패/엣지케이스 시나리오

**Case 1: 필수 필드 미입력**

**입력:**
- 사용자가 아이디 또는 비밀번호를 입력하지 않고 로그인 버튼 클릭

**처리:**
1. 클라이언트: React Hook Form이 필수 필드 검증 실패 감지
2. 클라이언트: Zod 스키마 검증에서 오류 발생
3. 클라이언트: 서버 요청 없이 클라이언트 측에서 처리 중단

**출력:**
- 로딩 인디케이터 표시되지 않음
- 해당 입력 필드 하단에 오류 메시지 표시
- 입력 필드에 오류 스타일 적용 (빨간색 테두리 등)
- 로그인 버튼 비활성화 또는 재클릭 가능 상태 유지

**Case 2: 잘못된 자격 증명**

**입력:**
- 사용자가 존재하지 않는 아이디 또는 잘못된 비밀번호 입력
- 로그인 버튼 클릭

**처리:**
1. 클라이언트: 클라이언트 측 검증 통과
2. 클라이언트: API 요청 전송
3. 서버: 사용자 자격 증명 확인 실패
4. 서버: HTTP 401 Unauthorized 응답 반환 (`{"detail": "Invalid credentials"}`)
5. 클라이언트: React Query의 onError 콜백 실행

**출력:**
- 로딩 인디케이터 숨김
- 오류 메시지 표시 (예: 전역 토스트 또는 폼 상단 알림)
- 입력 필드 초기화 또는 현재 값 유지
- 로그인 실패 횟수 추적 (선택 사항)

**Case 3: 네트워크 오류**

**입력:**
- 사용자가 유효한 정보를 입력하고 로그인 버튼 클릭
- 네트워크 연결 불안정 또는 서버 응답 없음

**처리:**
1. 클라이언트: API 요청 전송
2. 네트워크: 타임아웃 또는 연결 실패
3. 클라이언트: Fetch API에서 네트워크 오류 발생
4. 클라이언트: React Query가 재시도 로직 실행 (최대 3회)
5. 클라이언트: 재시도 실패 시 onError 콜백 실행

**출력:**
- 로딩 인디케이터 표시 (재시도 중)
- 재시도 실패 후 네트워크 오류 메시지 표시
- 사용자에게 재시도 버튼 제공

**Case 4: 서버 오류 (500)**

**입력:**
- 사용자가 로그인 시도
- 서버에서 내부 오류 발생

**처리:**
1. 클라이언트: API 요청 전송
2. 서버: 내부 오류 발생 (예: 데이터베이스 연결 실패)
3. 서버: HTTP 500 Internal Server Error 응답 반환
4. 클라이언트: React Query의 onError 콜백 실행

**출력:**
- 로딩 인디케이터 숨김
- 일반적인 오류 메시지 표시 (기술적 세부사항 노출 금지)
- 사용자에게 나중에 다시 시도하도록 안내

---

### 1.2. 로그아웃

#### 성공 시나리오 (Happy Path)

**입력:**
- 인증된 사용자가 헤더의 로그아웃 버튼 클릭

**처리:**
1. 클라이언트: 로그아웃 확인 다이얼로그 표시 (선택 사항)
2. 클라이언트: 로컬 스토리지 또는 쿠키에서 JWT 토큰 삭제
3. 클라이언트: Zustand 스토어의 인증 상태 초기화
4. 클라이언트: React Query 캐시 초기화
5. 클라이언트: Next.js Router로 로그인 페이지(`/login`)로 리다이렉트

**출력:**
- 로그아웃 성공 피드백 표시
- 로그인 페이지로 자동 이동
- 헤더에 사용자 정보 제거

**사이드이펙트:**
- 모든 인증 관련 데이터가 클라이언트에서 제거됨
- 보호된 페이지 접근 시 자동으로 로그인 페이지로 리다이렉트됨

---

### 1.3. 자동 로그인 (토큰 검증)

#### 성공 시나리오 (Happy Path)

**입력:**
- 사용자가 브라우저를 재시작하고 보호된 페이지 접근
- 로컬 스토리지에 유효한 JWT 토큰 존재

**처리:**
1. 클라이언트: 페이지 로드 시 로컬 스토리지에서 JWT 토큰 확인
2. 클라이언트: 토큰의 만료 시간 확인 (클라이언트 측)
3. 클라이언트: 유효한 토큰인 경우 Zustand 스토어에 인증 상태 복원
4. 클라이언트: 첫 API 요청 시 서버가 토큰 유효성 재확인
5. 서버: JWT 토큰 검증 (서명, 만료 시간 확인)

**출력:**
- 로그인 페이지 표시 없이 요청한 페이지 직접 표시
- 헤더에 사용자 정보 표시

#### 실패/엣지케이스 시나리오

**Case 1: 토큰 만료**

**입력:**
- 사용자가 보호된 페이지 접근
- 로컬 스토리지의 JWT 토큰이 만료됨 (24시간 경과)

**처리:**
1. 클라이언트: 토큰 만료 확인
2. 클라이언트: Refresh Token으로 새 Access Token 요청 (선택 사항)
3. 서버: Refresh Token 검증 실패 또는 Access Token 갱신 실패
4. 클라이언트: 인증 상태 초기화

**출력:**
- 세션 만료 메시지 표시
- 로그인 페이지로 자동 리다이렉트
- 로그인 후 원래 접근하려던 페이지로 복귀 (선택 사항)

**Case 2: 토큰 변조 또는 유효하지 않음**

**입력:**
- 사용자가 보호된 페이지 접근
- 로컬 스토리지의 JWT 토큰이 변조되었거나 유효하지 않음

**처리:**
1. 클라이언트: API 요청 시 토큰을 헤더에 포함
2. 서버: JWT 서명 검증 실패
3. 서버: HTTP 401 Unauthorized 응답 반환
4. 클라이언트: 인증 오류 감지

**출력:**
- 인증 오류 메시지 표시
- 로컬 스토리지의 토큰 삭제
- 로그인 페이지로 자동 리다이렉트

---

## 2. 데이터 업로드 (CSV Upload)

### 2.1. CSV 파일 업로드

#### 성공 시나리오 (Happy Path)

**입력:**
- 관리자 권한 사용자가 데이터 업로드 페이지(`/admin/upload`)에 접근
- 파일 업로드 영역에 CSV 파일 드래그 앤 드롭 또는 파일 선택 다이얼로그에서 파일 선택
- 데이터 유형 선택 (실적/논문/학생/예산)
- 업로드 버튼 클릭

**처리:**
1. 클라이언트: 파일 확장자 검증 (.csv만 허용)
2. 클라이언트: 파일 크기 검증 (최대 10MB 등)
3. 클라이언트: 데이터 유형 필수 선택 확인
4. 클라이언트: FormData 객체 생성 및 파일 및 메타데이터 추가
5. 클라이언트: `@/lib/remote/api-client`를 통해 `/api/data/upload` 엔드포인트로 POST 요청 (multipart/form-data)
6. 서버: Django REST Framework가 파일 수신
7. 서버: Serializer로 파일 및 데이터 유형 검증
8. 서버: 임시 디렉토리에 파일 저장
9. 서버: Pandas `read_csv()`로 CSV 파일 읽기 및 DataFrame 생성
10. 서버: 데이터 유형에 따라 적절한 컬럼 매핑 확인
11. 서버: 각 행 유효성 검증 (필수 컬럼, 데이터 타입, 범위 등)
12. 서버: 유효한 행만 Django ORM `bulk_create()` 또는 `update_or_create()`로 데이터베이스에 저장
13. 서버: 업로드 로그 생성 (UploadLog 모델에 기록)
14. 서버: JSON 응답 반환 (성공 행 수, 실패 행 수, 오류 상세 정보)
15. 클라이언트: React Query가 응답 데이터 수신
16. 클라이언트: 업로드 결과 화면에 표시

**출력:**
- 업로드 진행 중 로딩 인디케이터 또는 프로그레스 바 표시
- 업로드 완료 후 성공 메시지 표시
- 성공/실패 행 수 통계 표시
- 실패한 행이 있는 경우 상세 오류 목록 표시 (테이블 형식)
- 업로드 이력 테이블에 새 항목 추가

**사이드이펙트:**
- 데이터베이스에 새로운 데이터 행 추가됨
- UploadLog 테이블에 업로드 기록 저장됨
- 대시보드 차트 데이터 자동 갱신 (React Query 캐시 무효화)

#### 실패/엣지케이스 시나리오

**Case 1: 잘못된 파일 형식**

**입력:**
- 사용자가 .xlsx, .txt 등 CSV가 아닌 파일 업로드 시도

**처리:**
1. 클라이언트: 파일 확장자 검증 실패
2. 클라이언트: 서버 요청 없이 클라이언트 측에서 처리 중단

**출력:**
- 오류 메시지 표시 (지원하지 않는 파일 형식)
- 파일 선택 영역 강조 또는 오류 스타일 적용
- 업로드 버튼 비활성화

**Case 2: 파일 크기 초과**

**입력:**
- 사용자가 허용된 최대 크기를 초과하는 CSV 파일 업로드 시도

**처리:**
1. 클라이언트: 파일 크기 검증 실패
2. 클라이언트: 서버 요청 없이 클라이언트 측에서 처리 중단

**출력:**
- 오류 메시지 표시 (파일 크기가 너무 큼)
- 최대 허용 크기 안내
- 파일 선택 취소 또는 다른 파일 선택 유도

**Case 3: 데이터 유형 미선택**

**입력:**
- 사용자가 CSV 파일을 선택했으나 데이터 유형을 선택하지 않고 업로드 버튼 클릭

**처리:**
1. 클라이언트: 폼 검증에서 필수 필드 누락 감지
2. 클라이언트: 서버 요청 없이 클라이언트 측에서 처리 중단

**출력:**
- 데이터 유형 선택 필드에 오류 메시지 표시
- 해당 필드 강조 (빨간색 테두리 등)
- 업로드 버튼 비활성화 또는 재클릭 가능 상태 유지

**Case 4: CSV 컬럼 구조 불일치**

**입력:**
- 사용자가 올바른 CSV 파일을 업로드했으나 필수 컬럼이 누락되었거나 컬럼명이 일치하지 않음

**처리:**
1. 클라이언트: 파일 업로드 요청 전송
2. 서버: Pandas로 CSV 파일 읽기 성공
3. 서버: 데이터 유형에 따른 컬럼 매핑 확인 실패
4. 서버: HTTP 400 Bad Request 응답 반환 (`{"detail": "Missing required columns: [...]"}`)
5. 클라이언트: React Query의 onError 콜백 실행

**출력:**
- 로딩 인디케이터 숨김
- 오류 메시지 표시 (누락된 컬럼 목록 포함)
- 올바른 CSV 형식 예시 제공 (다운로드 가능한 템플릿 링크)
- 업로드 이력에 실패 기록 추가 (선택 사항)

**Case 5: 부분 실패 (일부 행만 유효)**

**입력:**
- 사용자가 CSV 파일을 업로드했으나 일부 행에 유효하지 않은 데이터 포함 (예: 잘못된 날짜 형식, 음수 값 등)

**처리:**
1. 클라이언트: 파일 업로드 요청 전송
2. 서버: Pandas로 CSV 파일 읽기 성공
3. 서버: 각 행 유효성 검증
4. 서버: 유효한 행만 데이터베이스에 저장
5. 서버: 유효하지 않은 행은 건너뛰고 오류 정보 수집
6. 서버: HTTP 207 Multi-Status 또는 HTTP 200 OK 응답 반환 (성공/실패 통계 포함)
7. 클라이언트: 부분 성공으로 처리

**출력:**
- 로딩 인디케이터 숨김
- 부분 성공 메시지 표시 (예: "100개 중 85개 행이 성공적으로 저장되었습니다")
- 성공 행 수 및 실패 행 수 통계 표시
- 실패한 행 목록 테이블 표시 (행 번호, 오류 원인)
- 실패한 행 데이터를 CSV로 다운로드 가능한 버튼 제공

**사이드이펙트:**
- 유효한 데이터만 데이터베이스에 저장됨
- UploadLog에 성공/실패 통계 기록됨
- 실패한 행 정보가 로그에 저장됨

**Case 6: 중복 데이터**

**입력:**
- 사용자가 이미 업로드된 데이터와 중복되는 CSV 파일 업로드

**처리:**
1. 클라이언트: 파일 업로드 요청 전송
2. 서버: CSV 파일 읽기 및 검증
3. 서버: Django ORM `update_or_create()`로 중복 데이터 처리 (업데이트 또는 새로 삽입)
4. 서버: 업데이트된 행 수 및 새로 삽입된 행 수 집계
5. 서버: HTTP 200 OK 응답 반환 (통계 포함)

**출력:**
- 업로드 완료 메시지 표시
- 새로 삽입된 행 수 및 업데이트된 행 수 통계 표시
- 중복 처리 방식 안내 (업데이트됨)

**Case 7: 네트워크 오류 또는 서버 타임아웃**

**입력:**
- 사용자가 대용량 CSV 파일 업로드 중 네트워크 연결 끊김 또는 서버 응답 시간 초과

**처리:**
1. 클라이언트: 파일 업로드 요청 전송
2. 네트워크: 연결 실패 또는 타임아웃
3. 클라이언트: Fetch API에서 네트워크 오류 발생
4. 클라이언트: React Query의 재시도 로직 실행 (대용량 파일은 재시도 제한)

**출력:**
- 로딩 인디케이터 표시 유지
- 네트워크 오류 메시지 표시
- 재시도 버튼 제공
- 업로드 취소 버튼 제공

**Case 8: 권한 없음 (관리자가 아닌 사용자)**

**입력:**
- 일반 사용자가 데이터 업로드 페이지 접근 시도

**처리:**
1. 클라이언트: 페이지 로드 시 사용자 권한 확인 (Zustand 스토어)
2. 클라이언트: 관리자 권한 없음 감지
3. 클라이언트: Next.js Router로 메인 대시보드 또는 접근 거부 페이지로 리다이렉트

**출력:**
- 접근 권한 없음 메시지 표시
- 메인 페이지로 자동 리다이렉트

---

### 2.2. 업로드 이력 조회

#### 성공 시나리오 (Happy Path)

**입력:**
- 관리자 권한 사용자가 데이터 업로드 페이지(`/admin/upload`)에 접근
- 페이지 하단의 업로드 이력 테이블 자동 표시

**처리:**
1. 클라이언트: 페이지 로드 시 `/api/data/upload-logs` 엔드포인트로 GET 요청
2. 서버: Django REST Framework가 요청 수신
3. 서버: UploadLog 모델에서 최근 업로드 기록 조회 (페이지네이션 적용)
4. 서버: Serializer로 데이터 직렬화
5. 서버: JSON 응답 반환 (업로드 로그 목록)
6. 클라이언트: React Query가 응답 데이터 수신 및 캐싱
7. 클라이언트: 테이블 컴포넌트에 데이터 렌더링

**출력:**
- 업로드 이력 테이블 표시 (파일명, 데이터 유형, 업로드 일시, 성공/실패 행 수, 업로드한 사용자)
- 페이지네이션 컨트롤 표시
- 각 항목의 상세 정보 보기 버튼

**사이드이펙트:**
- React Query 캐시에 업로드 로그 데이터 저장됨

---

### 2.3. 업로드 이력 상세 조회

#### 성공 시나리오 (Happy Path)

**입력:**
- 사용자가 업로드 이력 테이블에서 특정 항목의 상세 보기 버튼 클릭

**처리:**
1. 클라이언트: 모달 또는 확장 패널 표시
2. 클라이언트: `/api/data/upload-logs/{id}` 엔드포인트로 GET 요청
3. 서버: 해당 UploadLog 상세 정보 조회
4. 서버: JSON 응답 반환 (오류 메시지, 실패한 행 상세 정보 포함)
5. 클라이언트: React Query가 응답 데이터 수신
6. 클라이언트: 모달에 상세 정보 렌더링

**출력:**
- 모달 또는 확장 패널에 상세 정보 표시
- 실패한 행 목록 테이블 표시 (있는 경우)
- 오류 메시지 표시
- 닫기 버튼

---

## 3. 데이터 시각화 (Dashboard Visualization)

### 3.1. 메인 대시보드 조회 (Overview)

#### 성공 시나리오 (Happy Path)

**입력:**
- 인증된 사용자가 메인 대시보드 페이지(`/`)에 접근

**처리:**
1. 클라이언트: 페이지 로드 시 `/api/dashboard/overview` 엔드포인트로 GET 요청
2. 서버: Django REST Framework가 요청 수신
3. 서버: 4개 주요 지표(실적, 논문, 학생, 예산) 요약 데이터 조회
4. 서버: 각 데이터 모델에서 집계 쿼리 실행 (최신 데이터, 전체 통계 등)
5. 서버: Serializer로 데이터 직렬화
6. 서버: JSON 응답 반환 (4개 카드 데이터)
7. 클라이언트: React Query가 응답 데이터 수신 및 캐싱 (staleTime 5분)
8. 클라이언트: 4개 카드 컴포넌트에 데이터 렌더링

**출력:**
- 로딩 중 스켈레톤 UI 표시
- 로딩 완료 후 4개 주요 지표 카드 표시 (Grid Layout)
  - 실적 카드: 최신 달성률, 간단한 차트
  - 논문 카드: 총 논문 수, 간단한 차트
  - 학생 카드: 총 학생 수, 간단한 차트
  - 예산 카드: 예산 집행률, 간단한 차트
- 각 카드에 상세 페이지로 이동하는 버튼 또는 링크

**사이드이펙트:**
- React Query 캐시에 대시보드 데이터 저장됨

#### 실패/엣지케이스 시나리오

**Case 1: 데이터 없음**

**입력:**
- 사용자가 메인 대시보드에 접근했으나 아직 업로드된 데이터가 없음

**처리:**
1. 클라이언트: API 요청 전송
2. 서버: 데이터베이스에서 데이터 조회
3. 서버: 빈 결과 또는 기본값 반환
4. 클라이언트: 빈 데이터 감지

**출력:**
- 빈 상태(Empty State) UI 표시
- "아직 데이터가 없습니다" 메시지 표시
- 데이터 업로드 페이지로 이동하는 버튼 제공 (관리자만)

**Case 2: API 오류**

**입력:**
- 사용자가 메인 대시보드에 접근
- 서버에서 오류 발생

**처리:**
1. 클라이언트: API 요청 전송
2. 서버: 내부 오류 발생 (예: 데이터베이스 쿼리 실패)
3. 서버: HTTP 500 Internal Server Error 응답 반환
4. 클라이언트: React Query의 onError 콜백 실행

**출력:**
- 로딩 인디케이터 숨김
- 오류 메시지 표시 (전역 또는 카드별)
- 재시도 버튼 제공

**Case 3: 느린 로딩 (3초 초과)**

**입력:**
- 사용자가 메인 대시보드에 접근
- 서버 응답이 3초 이상 지연

**처리:**
1. 클라이언트: API 요청 전송
2. 서버: 대용량 데이터 집계로 인한 지연
3. 클라이언트: 3초 경과 후에도 응답 대기 중

**출력:**
- 로딩 인디케이터 지속 표시
- 3초 후 추가 메시지 표시 (예: "데이터를 불러오는 중입니다...")
- 타임아웃 설정에 따라 최대 대기 시간 후 오류 처리

---

### 3.2. 실적 대시보드 조회

#### 성공 시나리오 (Happy Path)

**입력:**
- 인증된 사용자가 실적 대시보드 페이지(`/dashboard/performance`)에 접근
- 선택적으로 필터 옵션 선택 (연도, 월, 부서)

**처리:**
1. 클라이언트: 페이지 로드 시 기본 필터로 `/api/dashboard/performance` 엔드포인트로 GET 요청
2. 서버: 쿼리 파라미터로 필터 조건 수신
3. 서버: PerformanceData 모델에서 필터링 및 집계 쿼리 실행
4. 서버: 차트 데이터 형식으로 가공 (시계열, 부서별 등)
5. 서버: Serializer로 데이터 직렬화
6. 서버: JSON 응답 반환 (차트 데이터, 통계 데이터)
7. 클라이언트: React Query가 응답 데이터 수신 및 캐싱
8. 클라이언트: Recharts 또는 Chart.js로 차트 렌더링

**출력:**
- 로딩 중 스켈레톤 UI 표시
- 로딩 완료 후 차트 표시 (2x2 Grid Layout)
  - 목표 대비 실적 추이 (라인 차트)
  - 부서별 달성률 (막대 차트)
  - 월별 실적 분포 (라인 차트)
  - 전체 달성률 요약 (파이 차트 또는 게이지)
- 필터 컨트롤 표시 (연도, 월, 부서 선택)
- 데이터 테이블 표시 (하단)

**사이드이펙트:**
- React Query 캐시에 실적 데이터 저장됨
- 필터 상태가 URL 쿼리 파라미터 또는 로컬 상태에 저장됨

#### 실패/엣지케이스 시나리오

**Case 1: 필터링된 결과 없음**

**입력:**
- 사용자가 특정 연도 및 부서로 필터링
- 해당 조건의 데이터가 없음

**처리:**
1. 클라이언트: 필터 변경 시 API 요청 전송
2. 서버: 필터링 쿼리 실행
3. 서버: 빈 결과 반환
4. 클라이언트: 빈 데이터 감지

**출력:**
- 차트 영역에 빈 상태 UI 표시
- "선택한 조건에 해당하는 데이터가 없습니다" 메시지 표시
- 필터 초기화 버튼 제공

**Case 2: 차트 렌더링 오류**

**입력:**
- 서버에서 올바른 데이터를 반환했으나 차트 라이브러리에서 렌더링 실패

**처리:**
1. 클라이언트: 차트 컴포넌트에서 데이터 처리 중 오류 발생
2. 클라이언트: Error Boundary가 오류 캐치

**출력:**
- 차트 영역에 오류 메시지 표시
- 대체 UI 제공 (데이터 테이블만 표시)
- 새로고침 버튼 제공

---

### 3.3. 논문/학생/예산 대시보드 조회

논문, 학생, 예산 대시보드는 실적 대시보드와 동일한 상호작용 흐름을 따릅니다.

**입력:**
- 인증된 사용자가 각 대시보드 페이지에 접근 (`/dashboard/papers`, `/dashboard/students`, `/dashboard/budget`)
- 선택적으로 필터 옵션 선택

**처리:**
1. 클라이언트: 해당 데이터 엔드포인트로 GET 요청 (`/api/dashboard/papers`, `/api/dashboard/students`, `/api/dashboard/budget`)
2. 서버: 해당 데이터 모델에서 데이터 조회 및 집계
3. 서버: JSON 응답 반환
4. 클라이언트: React Query가 응답 데이터 수신 및 차트 렌더링

**출력:**
- 각 대시보드에 맞는 차트 표시
  - 논문: 국내/국제 논문 수, 연도별 추이, 부서별 분포
  - 학생: 학년별/전공별 학생 수, 학기별 추이, 재학생 통계
  - 예산: 분기별 예산 집행률, 부서별 예산, 카테고리별 지출
- 필터 및 데이터 테이블 표시

**엣지케이스는 실적 대시보드와 동일하게 처리됩니다.**

---

### 3.4. 데이터 테이블 조회 (Raw Data)

#### 성공 시나리오 (Happy Path)

**입력:**
- 사용자가 대시보드 하단의 데이터 테이블 영역 확인
- 선택적으로 정렬, 페이지네이션 컨트롤 사용

**처리:**
1. 클라이언트: 차트 데이터와 동일한 API 응답에서 테이블 데이터 추출 또는 별도 요청
2. 클라이언트: shadcn-ui Table 컴포넌트에 데이터 바인딩
3. 클라이언트: 정렬 또는 페이지 변경 시 로컬 처리 또는 API 재요청

**출력:**
- 테이블 형식으로 데이터 표시 (컬럼: 연도, 월, 부서, 목표, 실적 등)
- 정렬 가능한 컬럼 헤더 표시
- 페이지네이션 컨트롤 표시
- CSV 다운로드 버튼 (선택 사항)

**사이드이펙트:**
- 정렬 또는 페이지 상태가 로컬 상태에 저장됨

---

### 3.5. 데이터 다운로드 (CSV Export)

#### 성공 시나리오 (Happy Path)

**입력:**
- 사용자가 데이터 테이블 하단의 CSV 다운로드 버튼 클릭

**처리:**
1. 클라이언트: 현재 필터링된 데이터를 CSV 형식으로 변환 (클라이언트 측) 또는 서버에 다운로드 요청
2. 서버 (옵션): `/api/dashboard/performance/export` 엔드포인트로 GET 요청 수신
3. 서버: 필터링된 데이터 조회
4. 서버: CSV 파일 생성 (Pandas `to_csv()`)
5. 서버: HTTP 응답으로 CSV 파일 반환 (`Content-Type: text/csv`, `Content-Disposition: attachment`)
6. 클라이언트: 브라우저가 파일 다운로드 시작

**출력:**
- 다운로드 진행 중 로딩 인디케이터 표시 (선택 사항)
- 브라우저가 CSV 파일 다운로드 다이얼로그 표시
- 파일 다운로드 완료 후 성공 피드백 (선택 사항)

**사이드이펙트:**
- 사용자의 로컬 디스크에 CSV 파일 저장됨

---

### 3.6. 필터 적용

#### 성공 시나리오 (Happy Path)

**입력:**
- 사용자가 대시보드 페이지의 필터 컨트롤에서 옵션 선택 (예: 연도 선택, 부서 선택)
- 적용 버튼 클릭 또는 자동 적용

**처리:**
1. 클라이언트: 필터 상태 업데이트 (React 로컬 상태 또는 URL 쿼리 파라미터)
2. 클라이언트: React Query의 queryKey가 변경되어 자동으로 새로운 API 요청 트리거
3. 서버: 새로운 필터 조건으로 데이터 조회
4. 서버: JSON 응답 반환
5. 클라이언트: React Query가 응답 데이터 수신 및 차트 재렌더링

**출력:**
- 로딩 중 차트 영역에 로딩 인디케이터 표시
- 로딩 완료 후 필터링된 데이터로 차트 업데이트
- 데이터 테이블도 함께 업데이트
- URL 쿼리 파라미터 업데이트 (페이지 새로고침 시 필터 상태 유지)

**사이드이펙트:**
- React Query 캐시에 필터별 데이터 저장됨 (각 필터 조합이 별도 캐시 키)
- URL 쿼리 파라미터 변경됨

---

### 3.7. 차트 상호작용 (툴팁, 줌 등)

#### 성공 시나리오 (Happy Path)

**입력:**
- 사용자가 차트 위에 마우스를 올려 특정 데이터 포인트를 호버
- 또는 차트 영역을 드래그하여 줌 인/아웃

**처리:**
1. 클라이언트: 차트 라이브러리(Recharts 또는 Chart.js)의 이벤트 핸들러 실행
2. 클라이언트: 툴팁 데이터 계산 및 렌더링
3. 클라이언트: 줌 레벨 조정 및 차트 재렌더링

**출력:**
- 호버 시 툴팁 표시 (해당 데이터 포인트의 상세 정보)
- 줌 인/아웃 시 차트 범위 조정
- 줌 초기화 버튼 표시 (줌 적용 시)

**사이드이펙트:**
- 차트 상태가 로컬 상태에 저장됨 (줌 레벨 등)

---

## 4. 관리자 설정 (Admin Settings)

### 4.1. 사용자 관리 (MVP 제외, 추후 구현)

MVP에서는 단일 관리자 계정만 지원하므로 사용자 관리 기능은 제외됩니다.

---

### 4.2. 시스템 설정 조회 및 수정 (MVP 제외, 추후 구현)

MVP에서는 기본 설정만 제공하므로 설정 페이지는 제외됩니다.

---

## 5. 공통 상호작용

### 5.1. 페이지 네비게이션

**입력:**
- 사용자가 헤더의 네비게이션 메뉴 항목 클릭 또는 사이드바의 링크 클릭

**처리:**
1. 클라이언트: Next.js Router의 `router.push()` 호출
2. 클라이언트: 페이지 컴포넌트 언마운트 및 새 페이지 컴포넌트 마운트
3. 클라이언트: 새 페이지의 데이터 요청 시작

**출력:**
- 부드러운 페이지 전환 애니메이션 (선택 사항)
- 새 페이지 로딩 중 스켈레톤 UI 표시
- URL 변경

---

### 5.2. 오류 처리 (전역)

**입력:**
- 애플리케이션 어디에서든 예기치 않은 오류 발생

**처리:**
1. 클라이언트: Error Boundary가 오류 캐치
2. 클라이언트: 오류 로그 수집 (콘솔 또는 외부 서비스)
3. 클라이언트: 대체 UI 렌더링

**출력:**
- 오류 페이지 또는 오류 메시지 표시
- 홈으로 돌아가기 버튼 또는 페이지 새로고침 버튼 제공
- 기술 지원 연락처 정보 제공 (선택 사항)

---

### 5.3. 접근 권한 확인 (보호된 페이지)

**입력:**
- 사용자가 보호된 페이지(대시보드, 관리자 페이지 등)에 접근 시도

**처리:**
1. 클라이언트: 페이지 컴포넌트의 useEffect 또는 미들웨어에서 인증 상태 확인
2. 클라이언트: Zustand 스토어에서 JWT 토큰 및 사용자 정보 확인
3. 클라이언트: 인증되지 않은 경우 로그인 페이지로 리다이렉트
4. 클라이언트: 관리자 권한이 필요한 페이지의 경우 권한 추가 확인

**출력:**
- 인증되지 않은 경우: 로그인 페이지로 리다이렉트
- 권한 없는 경우: 접근 거부 페이지 또는 메인 페이지로 리다이렉트

---

### 5.4. 데이터 자동 갱신 (React Query Refetch)

**입력:**
- 사용자가 특정 페이지에 일정 시간(예: 5분) 이상 머물러 있음
- 또는 다른 탭에서 돌아옴

**처리:**
1. 클라이언트: React Query의 `staleTime` 및 `refetchInterval` 설정에 따라 자동으로 데이터 재요청
2. 클라이언트: 백그라운드에서 API 요청 전송
3. 서버: 최신 데이터 반환
4. 클라이언트: React Query가 캐시 업데이트 및 UI 재렌더링

**출력:**
- 자동으로 최신 데이터로 차트 및 테이블 업데이트
- 사용자에게 눈에 띄는 로딩 표시 없음 (백그라운드 갱신)
- 선택적으로 "데이터가 업데이트되었습니다" 알림 표시

---

### 5.5. 반응형 디자인 (모바일/태블릿)

**입력:**
- 사용자가 모바일 또는 태블릿 기기로 접근
- 또는 데스크톱에서 브라우저 창 크기 조정

**처리:**
1. 클라이언트: Tailwind CSS의 반응형 클래스에 따라 레이아웃 자동 조정
2. 클라이언트: 작은 화면에서는 네비게이션 메뉴가 햄버거 메뉴로 전환
3. 클라이언트: 차트 크기 및 레이아웃 자동 조정

**출력:**
- 모바일: 단일 컬럼 레이아웃, 햄버거 메뉴, 축소된 차트
- 태블릿: 2컬럼 레이아웃, 중간 크기 차트
- 데스크톱: 4컬럼 또는 Grid 레이아웃, 전체 크기 차트

---

## 6. 성능 및 보안 관련 상호작용

### 6.1. API 요청 최적화 (Debounce/Throttle)

**입력:**
- 사용자가 필터 입력 필드에 빠르게 연속으로 입력

**처리:**
1. 클라이언트: react-use의 `useDebounce` 훅으로 입력 디바운싱
2. 클라이언트: 마지막 입력 후 500ms 대기
3. 클라이언트: 디바운싱된 값으로 API 요청 전송

**출력:**
- 불필요한 API 요청 방지
- 사용자 입력 중 로딩 표시 최소화

---

### 6.2. HTTPS 및 CORS 처리

**입력:**
- 프론트엔드에서 백엔드 API 요청 전송

**처리:**
1. 클라이언트: HTTPS 프로토콜로 요청 전송
2. 서버: Django의 `django-cors-headers`가 CORS 헤더 추가
3. 브라우저: CORS 검증 통과 후 응답 수신

**출력:**
- 안전한 데이터 전송 보장
- CORS 오류 없이 API 통신 성공

---

### 6.3. SQL Injection 및 XSS 방지

**입력:**
- 사용자가 입력 필드에 악의적인 스크립트 또는 SQL 구문 입력 시도

**처리:**
1. 클라이언트: React의 자동 이스케이핑으로 XSS 방지
2. 서버: Django ORM이 쿼리 파라미터를 자동으로 이스케이핑하여 SQL Injection 방지
3. 서버: Serializer가 입력 데이터 검증 및 정제

**출력:**
- 악의적인 입력이 실행되지 않음
- 정상적인 데이터만 처리됨

---

## 7. 엣지케이스 종합 정리

### 7.1. 동시 접근 및 충돌

**시나리오:** 두 명의 관리자가 동시에 동일한 데이터 유형의 CSV 파일을 업로드

**처리:**
1. 서버: Django의 `transaction.atomic()`으로 데이터베이스 트랜잭션 보장
2. 서버: 각 업로드가 독립적으로 처리됨
3. 서버: `update_or_create()`로 중복 데이터 자동 해결

**출력:**
- 두 업로드 모두 성공적으로 처리됨
- 충돌하는 데이터는 최신 업로드로 업데이트됨

---

### 7.2. 브라우저 호환성

**시나리오:** 사용자가 오래된 브라우저(IE11 등)로 접근

**처리:**
1. 클라이언트: Polyfill 및 Transpile로 기본 호환성 제공
2. 클라이언트: 지원하지 않는 기능 감지 시 대체 UI 제공

**출력:**
- 지원하지 않는 브라우저 안내 메시지 표시
- 최신 브라우저 사용 권장

---

### 7.3. 대용량 데이터 처리

**시나리오:** 관리자가 100,000행 이상의 대용량 CSV 파일 업로드

**처리:**
1. 클라이언트: 파일 크기 제한으로 업로드 차단 (최대 10MB 등)
2. 서버: 허용된 경우 Pandas 청크 읽기로 메모리 효율적 처리
3. 서버: 배치 삽입으로 성능 최적화

**출력:**
- 대용량 파일 업로드 차단 메시지 표시
- 또는 청크 단위 업로드 진행률 표시

---

## 8. 요약

본 문서는 대학교 데이터 시각화 대시보드의 주요 기능에 대한 사용자 상호작용을 '입력, 처리, 출력' 구조로 상세히 정의하였습니다. 모든 주요 사용자 시나리오와 엣지케이스를 포함하여, 개발 팀이 일관되고 예측 가능한 사용자 경험을 구현할 수 있도록 명세하였습니다.

각 상호작용은 다음 원칙을 준수합니다:
- **명확한 입력 정의:** 사용자의 모든 액션을 구체적으로 명시
- **단계별 처리 과정:** 클라이언트와 서버의 처리 로직을 순차적으로 기술
- **포괄적인 출력 정의:** UI 피드백 및 사이드이펙트를 모두 포함
- **엣지케이스 대응:** 실패 시나리오 및 예외 상황에 대한 명확한 처리 방법 제시
